{"version":3,"file":"src_App_tsx.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;;AAGA;;AAOA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAGA;;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAGA;;AAEA;;;;;;;;;;;;;;ACpDA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACdA;AAEA;AAAA;;AAAA;AAIA;AACA;;AALA;AAOA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;;AACA;AACA;;AA5BA;AA8BA;AACA;AACA;AACA;AA/BA;;AAJA","sources":["webpack://happybirthday/./src/App.tsx","webpack://happybirthday/./src/Executives/CalculateBoxSize.tsx","webpack://happybirthday/./src/Executives/GenerateColours.tsx"],"sourcesContent":["import React, { useEffect, useState, lazy, useRef } from \"react\";\r\nimport { Colour } from \"./Types/GeneralTypes\";\r\nimport { ColourGenerator } from \"./Executives/GenerateColours\";\r\nimport { calculateBoxSize } from \"./Executives/CalculateBoxSize\";\r\n\r\n//Lazy loading to separate the weight of the build bundle.\r\nconst ColourBox = lazy(() => import(\"./Shared-Components/ColourBox\"));\r\n\r\ninterface CanvasDimantions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nfunction App(): React.ReactElement {\r\n  const [colours, setColours] = useState<Colour[] | null>(null);\r\n  const [canvasSize, setCanvasSize] = useState<CanvasDimantions>({\r\n    width: 0,\r\n    height: 0,\r\n  });\r\n  const containerQuery = useRef<HTMLDivElement>(null);\r\n\r\n  //Using useEffect hook I am calling a class to generate the colours and return them in a sorted array;\r\n  //useEffect helps to generate this class just once the first paint happens.\r\n  useEffect(() => {\r\n    //Run functions handle the callback chain.\r\n    setColours(new ColourGenerator().run());\r\n  }, []);\r\n\r\n  // To correctly calculate the size of each box you have to first calculate the surfacer of the canvas then divide it by the number of boxes.\r\n  // So it will be 2c*2c=4c and to fit 6 boxes in this canvas you have to 4/6=0.666. So the width and height for perfect rectangles will be 0.666/2.\r\n  useEffect(() => {\r\n    let canvasWidth: number = 0;\r\n    let canvasHeight: number = 0;\r\n    if (colours && containerQuery.current) {\r\n      canvasWidth = containerQuery.current.clientWidth;\r\n      canvasHeight = containerQuery.current.clientHeight;\r\n    }\r\n\r\n    const args = {\r\n      width: canvasWidth,\r\n      height: canvasHeight,\r\n      cellNumber: 32768,\r\n    };\r\n    setCanvasSize(calculateBoxSize(args));\r\n  }, [containerQuery.current]);\r\n\r\n  return (\r\n    <div className=\"container\" ref={containerQuery}>\r\n      {canvasSize.width &&\r\n        colours?.map((colour: Colour, index) => {\r\n          const props = { ...colour, ...canvasSize, index };\r\n          return <ColourBox key={index} {...props} />;\r\n        })}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","interface Props {\r\n  width: number;\r\n  height: number;\r\n  cellNumber: number;\r\n}\r\n//I have generated this solution when I was cooking diner by drawing the problem on the stove. ðŸ˜ƒ\r\n\r\n// this function helps to grasp the span elements size. \r\n\r\n// To correctly calculate the size of each box you have to first calculate the surfacer of the canvas then divide it by the number of boxes.\r\n// So it will be 2c*2c=4c and to fit 6 boxes in this canvas you have to 4/6=0.666. So the width and height for perfect rectangles will be 0.666/2.\r\nexport const calculateBoxSize = ({ width, height, cellNumber }: Props) => {\r\n  const w = width / cellNumber / 2;\r\n  const h = height / cellNumber / 2;\r\n  //I timed values to 100 to be used as percentages.\r\n  return { width: w * 100, height: h * 100 };\r\n};\r\n","import { Colour } from \"../Types/GeneralTypes\";\r\n\r\nexport class ColourGenerator{\r\n  colors: Colour[]=[];\r\n  constructor(){\r\n\r\n  }\r\n  run=()=>{\r\n    return this.sortColours();\r\n  }\r\n  generateColours=()=>{\r\n    //This nested loop is my solution to avoid duplication in the array.\r\n    //Because for each iteration at list one value will change we can make sure there will not be any duplications\r\n    //in the array.\r\n    //Considering that this nested loop just runs at the first page I think the time complexity is forgivable.\r\n    const increment = Math.round(255 / 32);\r\n    for (let r = 0; r < 255; r += increment) {\r\n      for (let g = 0; g < 255; g += increment) {\r\n        for (let b = 0; b < 255; b += increment) {\r\n          //Calculating the average of the colour generated for soring.\r\n          const average = (r + g + b) / 3;\r\n          const color = {\r\n            red: Math.round(r),\r\n            green: Math.round(g),\r\n            blue: Math.round(b),\r\n            average: average,\r\n          };\r\n          this.colors.push(color);\r\n        }\r\n      }\r\n    }\r\n    return this.colors;\r\n  }\r\n  sortColours=(args: Colour[] | null=null)=>{\r\n    const colorsGenerated= args ? args : this.generateColours();\r\n    this.colors=colorsGenerated.sort((a,b)=> a.average-b.average)\r\n    return this.colors;\r\n  }\r\n}  \r\n"],"names":[],"sourceRoot":""}